[BITS 16]
[ORG 0X1000]

; VOID PRINT_STR(STR SI)
; VOID READ_STR(STR DI, INT SI)
; VOID STR_TO_NUM(STR SI, INT *DX)
; VOID NUM_TO_STR(INT|FLOAT [RES], BOOL BX)
; VOID CLEAR_STRING(STRING DI, SIZE CX)
; VOID CRLF()

START: ; NASM PERMITE O USO DE REGISTRADORES DE 32 BITS EM MODO REAL
    MOV EAX, CR0
    AND AL, 0XFB ; DESATIVACAO DE EMULACAO DA FPU, FORCA USO DO HARDWARE
    OR AL, 0X20 ; ATIVA CHECAGEM DE ERROS DA FPU
    MOV CR0, EAX
    XOR EAX, EAX
    CALL CLEAR_SCREEN
    CLD
    FINIT ; INICIALIZA FPU PARA OPERACOES DE PONTO FLUTUANTE

MENU:
    MOV SI, MENU_STR
    CALL PRINT_STR

INPUT:
    MOV SI, INPUT_STR
    CALL PRINT_STR

    MOV DI, OPT
    MOV SI, 1
    CALL READ_STR

    CMP BYTE [OPT], '1'
    JL .INVALID_OPT
    CMP BYTE [OPT], '5'
    JG .INVALID_OPT
    JE CONTINUE.END

    JMP NUM_INPUT

    .INVALID_OPT:
        MOV SI, INVALID_OPT_MSG
        CALL PRINT_STR
        JMP INPUT

NUM_INPUT:
    MOV SI, NUM1_MSG
    CALL PRINT_STR

    MOV DI, NUM1_STR
    MOV SI, 6
    CALL READ_STR

    MOV SI, NUM1_STR
    MOV DX, NUM1
    CALL STR_TO_NUM
    FILD WORD [NUM1] ; CARREGA WORD COMO INTEIRO PARA STACK DA FPU
    XOR DX, DX

    MOV SI, NUM2_MSG
    CALL PRINT_STR

    MOV DI, NUM2_STR
    MOV SI, 6
    CALL READ_STR

    MOV SI, NUM2_STR
    MOV DX, NUM2
    CALL STR_TO_NUM
    FILD WORD [NUM2]
    XOR DX, DX

    MOV SI, RESULT_MSG
    CALL PRINT_STR

    CMP BYTE [OPT], '1'
    JE ADD_OP
    CMP BYTE [OPT], '2'
    JE SUB_OP
    CMP BYTE [OPT], '3'
    JE MUL_OP
    CMP BYTE [OPT], '4'
    JE DIV_OP

CONTINUE:
    CALL CRLF ; IMPRIME NOVA LINHA E RETORNA CURSOR PARA COMECO DA LINHA

    MOV SI, CONTINUE_STR
    CALL PRINT_STR

    MOV DI, OPT
    MOV SI, 1
    CALL READ_STR

    MOV AL, [OPT]
    CMP AL, 'Y'
    JE .TO_MENU
    CMP AL, 'y'
    JE .TO_MENU
    CMP AL, 'N'
    JE .END
    CMP AL, 'n'
    JE .END

    MOV SI, INVALID_MSG
    CALL PRINT_STR
    JMP CONTINUE

    .END:
        MOV SI, END_MSG
        CALL PRINT_STR

        JMP $ ; JUMP INFINITO PARA POSICAO ATUAL

    .TO_MENU:
        MOV WORD [NUM1], 0 ; ZERA TODOS AS ENTRADAS DE USUARIO
        MOV WORD [NUM2], 0
        MOV WORD [INT_PART], 0
        MOV WORD [FRAC_PART], 0
        MOV CX, 32
        MOV DI, NUM1_STR
        CALL CLEAR_STRING
        MOV CX, 32
        MOV DI, NUM2_STR
        CALL CLEAR_STRING
        MOV CX, 32
        MOV DI, RESULT_STR
        CALL CLEAR_STRING
        MOV CX, 2
        MOV DI, OPT
        CALL CLEAR_STRING

        CALL CLEAR_SCREEN
        JMP MENU

ADD_OP:
    FADDP ; ST(1) += ST(0), POP ST(0)
    MOV BX, 0
    CALL NUM_TO_STR

    JMP CONTINUE

SUB_OP:
    FSUBP
    MOV BX, 0
    CALL NUM_TO_STR

    JMP CONTINUE

MUL_OP:
    FMULP
    MOV BX, 0
    CALL NUM_TO_STR

    JMP CONTINUE

DIV_OP:
    CMP WORD [NUM2], 0
    JE .DIV0_ERR

    FDIVP
    MOV BX, 1 ; DIVISAO PERMITE NUMERO REAL
    CALL NUM_TO_STR
    JMP CONTINUE

    .DIV0_ERR:
        MOV SI, DIV0_MSG
        CALL PRINT_STR
        JMP CONTINUE

PRINT_STR:
    PUSHA ; SALVA TODOS OS REGISTRADORES ANTES DAS OPERACOES A SEGUIR
    MOV AL, 0 ; LIMPA DADOS ANTERIORES

    MOV AH, 0X0E ; TELETYPE (EQUIVALENTE A PUTCHAR)
    MOV BH, 0 ; PAGINA 0 (OU TELA 0, A TELA PADRAO)
    MOV BL, 0X0F ; BH = 0 (PAGINA 0), BL = 0X0F (FUNDO PRETO, LETRA BRANCA)
    JMP .GETCH

    .PRINT:
        INT 0X10 ; SERVICOS DE VIDEO

    .GETCH:
        LODSB ; MOV AL, SI; INC SI (CARREGA CARACTER EM SI E INCREMENTA PONTEIRO)
        TEST AL, AL ; CHECA SE CHEGOU NO FIM DA STRING (SETA ZERO FLAG)
        JNZ .PRINT

    .DONE:
        POPA ; RETORNA VALOR ORIGINAL DOS REGISTRADORES
        RET

READ_STR:
    PUSHA
    XOR BX, BX

    .START:
        XOR AH, AH ; GETCHAR
        INT 0X16 ; AL = CHAR

        CMP AL, 13 ; DETECTA ENTER
        JE .DONE

    .TYPED_CHAR: ; IMPRIME CARACTER DIGITADO
        MOV AH, 0X0E
        PUSH BX
        MOV BX, 0X000F ; BH = 0, BL = 0X0F
        INT 0X10
        POP BX

    .POST_CHAR:
        CMP BX, SI ; LIMITE DE CARACTERES
        JE .DONE

    .BUFFERIZE:
        MOV [DI + BX], AL ; SALVA CARACTER EM BUFFER
        INC BX
        JMP .START

    .DONE:
        MOV BYTE [DI+BX], 0 ; CERTIFICA ULTIMO CARACTER COMO NULO
        CALL CRLF

        POPA
        RET

STR_TO_NUM: ; SUPORTA SOMENTE INTEIROS DE 16 BITS
    PUSHA
    XOR AX, AX
    XOR BX, BX
    XOR CX, CX

    LODSB ; PRIMEIRO CARACTER, CHECAGEM DE SINAL
    CMP AL, 0
    JE .DONE
    CMP AL, '-'
    JNE .DIGITS

    MOV BL, 1 ; SERVE COMO FLAG
    LODSB

    .DIGITS:
        MOV AH, 0
        CMP AL, 0
        JE .CHK

        CMP AL, '0'
        JL .INVALID
        CMP AL, '9'
        JG .INVALID

        SUB AL, '0' ; SUBTRAI '0', OBTEM-SE VALOR NUMERICO DO DIGITO
        IMUL CX, CX, 10 ; SOMA ORIGINAL * 10 PARA ACOMODAR NOVO DIGITO
        ADD CX, AX
        LODSB
        JMP .DIGITS

    .CHK:
        CMP BL, 1
        JNE .DONE
        NEG CX

    .DONE:
        XOR BX, BX
        MOV BX, DX ; DX NAO INDEXAVEL COMO [DX]
        MOV [BX], CX ; MAS BX SIM

        POPA
        RET

    .INVALID:
        MOV SI, NOT_NUM_MSG
        CALL PRINT_STR
        JMP CONTINUE

NUM_TO_STR:
    PUSHA
    XOR AX, AX

    MOV SI, RESULT_STR + 30 ; ESCREVE-SE NO FINAL DA STRING
    CLC ; ZERA CARRY FLAG
    TEST SI, SI ; COMO SI POSSUI VALOR != 0, ZERA ZERO FLAG
    CMP BX, 1
    JE .IS_FLOAT

    .INTEGERS:
        FISTP WORD [INT_PART] ; POP DA STACK DA FPU COMO INTEIRO DE 16 BITS
        MOV AX, [INT_PART]
        CMP AX, 0
        JGE .CONVERSION

        MOV AH, 0X0E
        MOV AL, '-'
        MOV BX, 0X000F
        INT 0X10

        NEG WORD [INT_PART]
        MOV AX, [INT_PART]

    .CONVERSION:
        XOR DX, DX ; PARA EVITAR ERROS
        DIV WORD [TEN] ; AX = AX / TEN, DX = AX % TEN
        ADD DL, '0'

        MOV BYTE [SI], DL
        DEC SI
        TEST AX, AX ; CHECA SE AINDA HA VALOR EM AX PARA CONVERTER
        JNZ .CONVERSION

        JMP .PRINT

    .IS_FLOAT:
        FLD ST0 ; DUPLICA VALOR NA STACK
        FISTTP WORD [INT_PART] ; INT_PART = (INT)ST0, ST1 = ST0, POP ST0

        MOV AX, [INT_PART]
        CMP AX, 0
        JGE .CONTINUE_FLOAT

        MOV AH, 0X0E
        MOV AL, '-'
        MOV BX, 0X000F
        INT 0X10

        NEG WORD [INT_PART] ; INT_PART = -INT_PART
        FCHS ; ST0 = -ST0

        .CONTINUE_FLOAT:
            FILD WORD [INT_PART] ; RECARREGA VALOR TRUNCADO
            FSUBP ST1, ST0 ; ST1 -= ST0 (SOMENTE CASAS DECIMAIS), POP ST0
            FILD DWORD [THSND]
            FMULP ST1, ST0
            FISTTP WORD [FRAC_PART] ; 3 DIGITOS DE PRECISAO

            MOV AX, [FRAC_PART] ; PARTE FRACIONARIA PODE SER NEGATIVA
            CMP AX, 0
            JGE .CONVERSION_DECIMAL

            NEG AX
            PUSH AX
            MOV AH, 0X0E
            MOV AL, '-'
            MOV BX, 0X000F
            INT 0X10
            POP AX

        .CONVERSION_DECIMAL:
            XOR DX, DX
            DIV WORD [TEN]
            ADD DL, '0'

            MOV BYTE [SI], DL
            DEC SI
            TEST AX, AX
            JNZ .CONVERSION_DECIMAL

            MOV BYTE [SI], '.'
            DEC SI

            MOV AX, [INT_PART] ; CONVERSAO NORMAL DA PARTE INTEIRA
            JMP .CONVERSION

    .PRINT:
        INC SI ; ESTAVA UM CARACTER ATRAS DO COMECO DA STRING
        CALL PRINT_STR
        CALL CRLF

        POPA
        RET

CRLF:
    PUSHA

    MOV AH, 0X0E ; IMPRIME CRLF
    MOV BX, 0X000F
    MOV AL, 13 ; RETORNO DE CARRO
    INT 0X10
    MOV AL, 10 ; NOVA LINHA
    INT 0X10

    POPA
    RET

CLEAR_SCREEN:
    PUSHA

    MOV AH, 0X0F
    INT 0X10 ; RETORNA MODO DE VIDEO ATUAL
    MOV AH, 0 ; ALTERA MODO DE VIDEO (AL OBTIDO POR INT 10H, 0FH)
    INT 0X10 ; MUDANCA DE MODO LIMPA A TELA (MESMO QUE MODO PERSISTA)

    POPA
    RET

CLEAR_STRING:
    PUSHA

    CLD ; LIMPA FLAG DE DIRECAO
    MOV AL, 0
    REP STOSB ; WHILE (CX) { DEC CX; MOV BYTE [DI + CX], AL; }

    POPA
    RET

MENU_STR: DB "ESCOLHA UMA OPCAO", 13, 10, "1 - SOMA", 13, 10
          DB "2 - SUBTRACAO", 13, 10, "3 - MULTIPLICACAO", 13, 10
          DB "4 - DIVISAO", 13, 10, "5 - SAIR", 13, 10, 10, 0
INPUT_STR: DB "OPCAO: ", 0
END_MSG: DB "TERMINADO", 0
RESULT_MSG: DB "RESULTADO: ", 0

NUM1_MSG: DB "DIGITE O NUMERO A: ", 0
NUM2_MSG: DB "DIGITE O NUMERO B: ", 0
NUM1: DW 0
NUM2: DW 0

TEN: DW 10
THSND: DD 1000
INT_PART: DW 0
FRAC_PART: DW 0

CONTINUE_STR: DB "DESEJA CONTINUAR (Y/N)? ", 0

INVALID_OPT_MSG: DB "OPCAO INVALIDA, TENTE NOVAMENTE.", 13, 10, 0
INVALID_MSG: DB "OPCAO INVALIDA.", 13, 10, 0
NOT_NUM_MSG: DB "NUMERO INVALIDO.", 13, 10, 0
DIV0_MSG: DB "INF!!", 13, 10, "DIVISAO POR 0 NAO PERMITIDA.", 13, 10, 0

OPT: TIMES 2 DB 0
NUM1_STR: TIMES 32 DB 0
NUM2_STR: TIMES 32 DB 0
RESULT_STR: TIMES 32 DB 0

ALIGN 512, DB 0 ; ALINHA PARA PROXIMO MULTIPLO DE 512 BYTES (PARA USO COM VBOX)
